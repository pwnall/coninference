// Generated by CoffeeScript 1.9.3
(function() {
  var ServiceWorkerRegistration, W3gram, W3gramGlobal, W3gramRequire;

  ServiceWorkerRegistration = (function() {
    function ServiceWorkerRegistration() {
      return;
    }

    ServiceWorkerRegistration.prototype.setupPushManager = function(options) {
      return this.pushRegistrationManager = new W3gram.PushRegistrationManager(options);
    };

    ServiceWorkerRegistration.prototype.pushRegistrationManager = null;

    return ServiceWorkerRegistration;

  })();

  W3gram = new ServiceWorkerRegistration();

  W3gram.ServiceWorkerRegistration = ServiceWorkerRegistration;

  W3gram._ = {};

  if (typeof global !== 'undefined' && typeof module !== 'undefined' && 'exports' in module) {
    W3gramGlobal = global;
    W3gramRequire = module.require.bind(module);
    module.exports = W3gram;
  } else if (typeof window !== 'undefined' && typeof navigator !== 'undefined') {
    W3gramGlobal = window;
    W3gramRequire = null;
    window.W3gram = W3gram;
  } else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {
    W3gramGlobal = self;
    W3gramRequire = self.importScripts.bind(self);
    self.W3gram = W3gram;
  } else {
    throw new Error('w3gram.js loaded in an unsupported JavaScript environment.');
  }

  W3gram._.global = W3gramGlobal;

  W3gram._.require = W3gramRequire;

  W3gram._.App = (function() {
    function App(json) {
      var serverUrl;
      if (!(this.apiKey = json.key)) {
        throw new Error('The key option must be a W3gram API key');
      }
      this.secret = json.secret || null;
      this.name = json.name || null;
      this.origin = json.origin || null;
      if (!(serverUrl = json.server)) {
        throw new Error('The server option must be a W3gram server URL');
      }
      if (serverUrl.substring(serverUrl.length - 1) === '/') {
        serverUrl = serverUrl.substring(0, serverUrl.length - 1);
      }
      this.serverUrl = serverUrl;
      this._registerUrl = serverUrl + "/register";
      return;
    }

    App.prototype.toJSON = function() {
      return {
        name: this.name,
        origin: this.origin,
        key: this.apiKey,
        secret: this.secret,
        server: this.serverUrl
      };
    };

    App.prototype.register = function(deviceId, token) {
      var registration;
      registration = {
        app: this.apiKey,
        device: deviceId,
        token: token
      };
      return W3gram._.jsonRequest('POST', this._registerUrl, registration).then((function(_this) {
        return function(json) {
          json.server = _this.serverUrl;
          json.app = _this.apiKey;
          json.device = deviceId;
          json.token = token;
          return new W3gram._.DeviceRegistration(json);
        };
      })(this));
    };

    App.prototype.token = function(deviceId) {
      return W3gram._.App.checkDeviceId(deviceId).then((function(_this) {
        return function() {
          return _this.checkCanCreateTokens().then(function() {
            return W3gram._.hmac(_this.secret, "device-id|" + deviceId);
          });
        };
      })(this));
    };

    App.checkDeviceId = function(deviceId) {
      if (W3gram._.App.isValidDeviceId(deviceId)) {
        return W3gram._.Promise.resolve(true);
      } else {
        return W3gram._.Promise.reject(new W3gram._.DOMException(W3gram._.DOMException.SyntaxError, 'Invalid device ID'));
      }
    };

    App.isValidDeviceId = function(deviceId) {
      if (!(deviceId.length <= 64)) {
        return false;
      }
      return /^[A-Za-z0-9_\-]+$/.test(deviceId);
    };

    App.prototype.checkCanCreateTokens = function() {
      if (this.secret) {
        return W3gram._.Promise.resolve(true);
      } else {
        return W3gram._.Promise.reject(new W3gram._.DOMException(W3gram._.DOMException.InvalidStateError, 'Cannot generate tokens without the app secret'));
      }
    };

    return App;

  })();

  W3gram._.DeviceRegistration = (function() {
    function DeviceRegistration(json) {
      this.pushUrl = json.push;
      this.routeUrl = json.route;
      return;
    }

    DeviceRegistration.prototype.push = function(message) {
      return W3gram._.jsonRequest('POST', this.pushUrl, {
        message: message
      }).then(function() {
        return true;
      });
    };

    DeviceRegistration.prototype.route = function() {
      return W3gram._.jsonRequest('POST', this.routeUrl, {}).then(function(json) {
        return json.listen;
      });
    };

    DeviceRegistration.prototype.toJSON = function() {
      return {
        push: this.pushUrl,
        route: this.routeUrl
      };
    };

    return DeviceRegistration;

  })();

  W3gram._.DOMException = (function() {
    function DOMException(name, message) {
      this.name = name;
      this.message = message;
    }

    DOMException.name = null;

    DOMException.NotFoundError = 'NotFoundError';

    DOMException.InvalidStateError = 'InvalidStateError';

    DOMException.SyntaxError = 'SyntaxError';

    DOMException.NotFoundError = 'NotFoundError';

    DOMException.SecurityError = 'SecurityError';

    DOMException.NetworkError = 'NetworkError';

    DOMException.AbortError = 'AbortError';

    DOMException.ABORT_ERR = 20;

    return DOMException;

  })();

  (function() {
    var _base64Digits, arrayToBase64, crypto, hmacSha256, requireError, sha256, sha256Init, sha256Key, stringToArray;
    W3gram._.hmac = function(key, string) {
      return new W3gram._.Promise(function(resolve) {
        return resolve(arrayToBase64(hmacSha256(stringToArray(key), stringToArray(string), key.length, string.length)));
      });
    };
    if (W3gram._.require) {
      try {
        crypto = W3gram._.require('crypto');
        if (crypto.createHmac) {
          W3gram._.hmac = function(key, string) {
            return new W3gram._.Promise(function(resolve) {
              return resolve(crypto.createHmac('sha256', key).update(string).digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, ''));
            });
          };
        }
      } catch (_error) {
        requireError = _error;
      }
    }
    hmacSha256 = function(key, string, keyLength, length) {
      var hash1, i, ipad, opad;
      if (key.length > 16) {
        key = sha256(key, keyLength);
      }
      ipad = (function() {
        var k, results;
        results = [];
        for (i = k = 0; k < 16; i = ++k) {
          results.push(key[i] ^ 0x36363636);
        }
        return results;
      })();
      opad = (function() {
        var k, results;
        results = [];
        for (i = k = 0; k < 16; i = ++k) {
          results.push(key[i] ^ 0x5C5C5C5C);
        }
        return results;
      })();
      hash1 = sha256(ipad.concat(string), 64 + length);
      return sha256(opad.concat(hash1), 64 + 32);
    };
    sha256 = function(string, length) {
      var a, a0, b, b0, c, c0, ch, d, d0, e, e0, f, f0, g, g0, gamma0, gamma0x, gamma1, gamma1x, h, h0, i, j, k, limit, maj, sigma0, sigma1, sj, state, t1, t2;
      string[length >> 2] |= 1 << (31 - ((length & 0x03) << 3));
      string[(((length + 8) >> 6) << 4) + 15] = length << 3;
      state = Array(80);
      a = sha256Init[0], b = sha256Init[1], c = sha256Init[2], d = sha256Init[3], e = sha256Init[4], f = sha256Init[5], g = sha256Init[6], h = sha256Init[7];
      i = 0;
      limit = string.length;
      while (i < limit) {
        a0 = a;
        b0 = b;
        c0 = c;
        d0 = d;
        e0 = e;
        f0 = f;
        g0 = g;
        h0 = h;
        for (j = k = 0; k < 64; j = ++k) {
          if (j < 16) {
            sj = state[j] = string[(i + j) << 2 >> 2] | 0;
          } else {
            gamma0x = state[(j - 15) << 2 >> 2] | 0;
            gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^ ((gamma0x << 14) | (gamma0x >>> 18)) ^ (gamma0x >>> 3);
            gamma1x = state[(j - 2) << 2 >> 2] | 0;
            gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^ ((gamma1x << 13) | (gamma1x >>> 19)) ^ (gamma1x >>> 10);
            sj = state[j] = (((gamma0 + (state[(j - 7) << 2 >> 2] | 0)) | 0) + ((gamma1 + (state[(j - 16) << 2 >> 2] | 0)) | 0)) | 0;
          }
          ch = (e & f) ^ (~e & g);
          maj = (a & b) ^ (a & c) ^ (b & c);
          sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
          sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));
          t1 = (((((h + sigma1) | 0) + ((ch + sj) | 0)) | 0) + (sha256Key[j << 2 >> 2] | 0)) | 0;
          t2 = (sigma0 + maj) | 0;
          h = g;
          g = f;
          f = e;
          e = (d + t1) | 0;
          d = c;
          c = b;
          b = a;
          a = (t1 + t2) | 0;
        }
        a = (a0 + a) | 0;
        b = (b0 + b) | 0;
        c = (c0 + c) | 0;
        d = (d0 + d) | 0;
        e = (e0 + e) | 0;
        f = (f0 + f) | 0;
        g = (g0 + g) | 0;
        h = (h0 + h) | 0;
        i += 16;
      }
      return [a, b, c, d, e, f, g, h];
    };
    sha256Init = [];
    sha256Key = [];
    (function() {
      var factor, fractional, i, isPrime, k, prime, results;
      fractional = function(x) {
        return ((x - Math.floor(x)) * 0x100000000) | 0;
      };
      prime = 2;
      results = [];
      for (i = k = 0; k < 64; i = ++k) {
        while (true) {
          isPrime = true;
          factor = 2;
          while (factor * factor <= prime) {
            if (prime % factor === 0) {
              isPrime = false;
              break;
            }
            factor += 1;
          }
          if (isPrime) {
            break;
          }
          prime += 1;
          continue;
        }
        if (i < 8) {
          sha256Init[i] = fractional(Math.pow(prime, 1 / 2));
        }
        sha256Key[i] = fractional(Math.pow(prime, 1 / 3));
        results.push(prime += 1);
      }
      return results;
    })();
    arrayToBase64 = function(array) {
      var i, i2, limit, string, trit;
      string = "";
      i = 0;
      limit = array.length * 4;
      while (i < limit) {
        i2 = i;
        trit = ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 16;
        i2 += 1;
        trit |= ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 8;
        i2 += 1;
        trit |= (array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF;
        string += _base64Digits[(trit >> 18) & 0x3F];
        string += _base64Digits[(trit >> 12) & 0x3F];
        i += 1;
        if (i < limit) {
          string += _base64Digits[(trit >> 6) & 0x3F];
        }
        i += 1;
        if (i < limit) {
          string += _base64Digits[trit & 0x3F];
        }
        i += 1;
      }
      return string;
    };
    _base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    return stringToArray = function(string) {
      var array, i, k, ref;
      array = [];
      for (i = k = 0, ref = string.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        array[i >> 2] |= (string.charCodeAt(i) & 0xFF) << ((3 - (i & 3)) << 3);
      }
      return array;
    };
  })();

  W3gram._.jsonRequest = function(method, url, body) {
    return new W3gram._.Promise(function(resolve, reject) {
      var xhr;
      xhr = new W3gram._.XMLHttpRequest();
      xhr.open(method, url, true);
      xhr.onreadystatechange = function() {
        var contentType, error, errorMessage, errorName, json, jsonError, offset, statusCode;
        if (xhr.readyState !== 4) {
          return true;
        }
        contentType = xhr.getResponseHeader('Content-Type');
        if (contentType) {
          offset = contentType.indexOf(';');
          if (offset !== -1) {
            contentType = contentType.substring(0, offset);
          }
        }
        json = null;
        jsonError = null;
        if (contentType === 'application/json') {
          try {
            json = JSON.parse(xhr.responseText || xhr.response);
          } catch (_error) {
            jsonError = _error;
          }
        }
        statusCode = xhr.status;
        if (statusCode >= 200 && statusCode < 300) {
          if (jsonError) {
            reject(jsonError);
            return;
          }
          resolve(json || {});
          return;
        }
        if (statusCode === 0) {
          errorName = W3gram._.DOMException.NetworkError;
          errorMessage = 'Could not reach Push Notification Server';
        } else {
          errorName = W3gram._.DOMException.SecurityError;
          if (json && json.error) {
            errorMessage = "Push Notification Server error: " + json.error;
          } else {
            errorMessage = "Push Notification Server error: HTTP " + statusCode;
          }
        }
        error = new W3gram._.DOMException(errorName, errorMessage);
        if (statusCode !== 0) {
          error.httpCode = statusCode;
        }
        reject(error);
      };
      if (body) {
        xhr.setRequestHeader('Content-Type', 'application/json; charset=utf-8');
        xhr.send(JSON.stringify(body));
      } else {
        xhr.send();
      }
    });
  };

  W3gram._.PingPong = (function() {
    function PingPong(options) {
      options || (options = {});
      this._silenceTimeout = options.silenceTimeoutMs || 5000;
      this._roundTrip = options.rttMs || 20000;
      this._pingSlack = options.pingSlackMs || 5000;
      this._nextPongNonce = 0;
      this._pongNonce = null;
      this._silenceTimer = null;
      this._pingTimer = null;
      this._silenceTimerHandler = this._onSilenceTimeout.bind(this);
      this._pingTimerHandler = this._onPingTimeout.bind(this);
      return;
    }

    PingPong.prototype.startedConnecting = function() {
      this._resetSilenceTimer();
    };

    PingPong.prototype.receivedPong = function(data) {
      var roundTrip;
      if (data.nonce === this._pongNonce) {
        roundTrip = Date.now() - data.ts;
        this._roundTrip = this._roundTrip * 0.875 + roundTrip * 0.125;
      }
      this._resetSilenceTimer();
    };

    PingPong.prototype.receivedMessage = function() {
      this._resetSilenceTimer();
    };

    PingPong.prototype.disconnected = function() {
      this._disableTimers();
    };

    PingPong.prototype.onPing = function(data) {
      throw new Error('onPing not assigned');
    };

    PingPong.prototype.onPingTimeout = function() {
      throw new Error('onPingTimeout not assigned');
    };

    PingPong.prototype._resetSilenceTimer = function() {
      this._disableTimers();
      this._silenceTimer = setTimeout(this._silenceTimerHandler, this._silenceTimeout);
    };

    PingPong.prototype._onSilenceTimeout = function() {
      if (this._silenceTimer === null) {
        return;
      }
      this._silenceTimer = null;
      if (this._pingTimer !== null) {
        return;
      }
      this._sendPing();
    };

    PingPong.prototype._sendPing = function() {
      this._pongNonce = this._nextPongNonce;
      this._nextPongNonce = (this._nextPongNouce + 1) | 0;
      this.onPing({
        nonce: this._pongNonce,
        ts: Date.now()
      });
      this._pingTimer = setTimeout(this._pingTimerHandler, this._roundTrip + this._pingSlack);
    };

    PingPong.prototype._onPingTimeout = function() {
      if (this._pingTimer === null) {
        return;
      }
      this._pingTimer = null;
      this._pongNonce = null;
      this._disableTimers();
      this.onPingTimeout();
    };

    PingPong.prototype._disableTimers = function() {
      if (this._pingTimer !== null) {
        clearTimeout(this._pingTimer);
        this._pingTimer = null;
        this._pongNonce = null;
      }
      if (this._silenceTimer !== null) {
        clearTimeout(this._silenceTimer);
        this._silenceTimer = null;
      }
    };

    return PingPong;

  })();

  if (typeof Promise === 'undefined') {
    W3gram._.Promise = W3gramRequire('es6-promise-polyfill').Promise;
  } else {
    W3gram._.Promise = Promise;
  }

  if (typeof WebSocket === 'undefined') {
    W3gram._.WebSocket = W3gramRequire('ws');
  } else {
    W3gram._.WebSocket = WebSocket;
  }

  if (typeof XMLHttpRequest === 'undefined') {
    W3gram._.XMLHttpRequest = W3gramRequire('xhr2');
  } else {
    W3gram._.XMLHttpRequest = XMLHttpRequest;
  }

  W3gram.PushEvent = (function() {
    function PushEvent(target, data) {
      this.name = 'PushEvent';
      this.target = target;
      this.data = data;
    }

    return PushEvent;

  })();

  W3gram._.createPushEvent = function(target, data) {
    return new W3gram.PushEvent(target, data);
  };

  W3gram.PushRegistration = (function() {
    function PushRegistration(deviceRegistration, options) {
      this._deviceRegistration = deviceRegistration;
      if (!(this._deviceRegistration instanceof W3gram._.DeviceRegistration)) {
        throw new Error('Illegal constructor');
      }
      this.endpoint = deviceRegistration.pushUrl;
      this._options = options;
      this._wsClient = null;
      this._canceled = false;
      this._initialBackoff = options.firstReconnectMs || 1000;
      this._maxBackoff = options.maxReconnectMs || 30000;
      this._nextBackoff = this._initialBackoff;
      this._resolveConnected = null;
      this._connected = new W3gram._.Promise((function(_this) {
        return function(resolve) {
          return _this._resolveConnected = resolve;
        };
      })(this));
      this._boundOnNotification = this._onNotification.bind(this);
      this._boundOnWsClosed = this._onWsClosed.bind(this);
      this._connect();
    }

    PushRegistration.prototype.endpoint = null;

    PushRegistration.prototype.onpush = null;

    PushRegistration.prototype.onpushregistrationlost = null;

    PushRegistration.prototype._cancel = function() {
      this._canceled = true;
      if (this._wsClient) {
        this._wsClient.close(1000, 'Receiver unregistered');
      }
    };

    PushRegistration.prototype._connect = function() {
      if (this._wsClient) {
        return W3gram._.Promise.resolve(true);
      }
      if (this._canceled) {
        return W3gram._.Promise.reject(new Error('Unregistered'));
      }
      return this._connectOnce();
    };

    PushRegistration.prototype._connectOnce = function() {
      this._deviceRegistration.route().then((function(_this) {
        return function(wsUrl) {
          _this._wsClient = new W3gram._.WsClient(wsUrl, _this._options);
          _this._wsClient.onNotification = _this._boundOnNotification;
          _this._wsClient.closed.then(_this._boundOnWsClosed);
          return _this._wsClient.connected;
        };
      })(this)).then((function(_this) {
        return function() {
          _this._nextBackoff = _this._initialBackoff;
          _this._resolveConnected(true);
          return true;
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          var timeoutMs;
          if (_this._wsClient) {
            _this._wsClient.close(4000, 'Network error');
          }
          timeoutMs = _this._nextBackoff;
          _this._nextBackoff *= 2;
          if (_this._nextBackoff > _this._maxBackoff) {
            _this._nextBackoff = _this._maxBackoff;
          }
          return new W3gram._.Promise(function(resolve) {
            var timeoutHandler;
            timeoutHandler = function() {
              return resolve(_this._connect());
            };
            return setTimeout(timeoutHandler, timeoutMs);
          });
        };
      })(this));
      return;
    };

    PushRegistration.prototype._onNotification = function(notification) {
      if (this._canceled) {
        return;
      }
      if (this.onpush) {
        this.onpush(W3gram._.createPushEvent(this, JSON.stringify(notification)));
      }
    };

    PushRegistration.prototype._onWsClosed = function(closeInfo) {
      if (closeInfo.client !== this._wsClient) {
        return;
      }
      this._wsClient = null;
      this._connect();
    };

    return PushRegistration;

  })();

  W3gram.PushRegistrationManager = (function() {
    function PushRegistrationManager(options) {
      if (!options.server) {
        throw new Error('The server option must be a W3gram server URL');
      }
      if (!options.key) {
        throw new Error('The key option must be a W3gram API key');
      }
      if (!(this._deviceId = options.device)) {
        throw new Error('The device option must be a device ID');
      }
      if (!(this._token = options.token)) {
        throw new Error("The token option must be the device ID's token");
      }
      this._registration = null;
      this._app = new W3gram._.App({
        server: options.server,
        key: options.key
      });
      this._timing = options.timing || {};
      return;
    }

    PushRegistrationManager.prototype.register = function() {
      if (this._registration !== null) {
        return W3gram._.Promise.resolve(this._registration);
      }
      return this._app.register(this._deviceId, this._token).then((function(_this) {
        return function(registration) {
          if (!_this._registration) {
            _this._registration = new W3gram.PushRegistration(registration, _this._timing);
          }
          return _this._registration._connected.then(function() {
            return _this._registration;
          });
        };
      })(this));
    };

    PushRegistrationManager.prototype.unregister = function() {
      var error, registration;
      if (this._registration) {
        registration = this._registration;
        this._registration = null;
        registration._cancel();
        W3gram._.Promise.resolve(registration);
        return;
      }
      error = new W3gram._.DOMException(W3gram._.DOMException.NotFoundError, 'No compatible W3gram registration found on this device');
      return W3gram._.Promise.reject(error);
    };

    PushRegistrationManager.prototype.getRegistration = function() {
      var error;
      if (this._registration) {
        W3gram._.Promise.resolve(this._registration);
        return;
      }
      error = new W3gram._.DOMException(W3gram._.DOMException.NotFoundError, 'No compatible W3gram registration found on this device');
      return W3gram._.Promise.reject(error);
    };

    PushRegistrationManager.prototype.hasPermission = function() {
      return W3gram._.Promise.resolve('granted');
    };

    return PushRegistrationManager;

  })();

  W3gram._.Server = (function() {
    function Server(serverUrl) {
      if (serverUrl.substring(serverUrl.length - 1) === '/') {
        serverUrl = serverUrl.substring(0, serverUrl.length - 1);
      }
      this.serverUrl = serverUrl;
      this._makUrl = serverUrl + "/mak";
      this._appsUrl = serverUrl + "/apps";
      return;
    }

    Server.prototype.getMak = function() {
      return W3gram._.jsonRequest('GET', this.serverUrl + "/mak").then(function(json) {
        return json.mak;
      });
    };

    Server.prototype.createApp = function(mak, options) {
      var app;
      app = {
        name: options.name,
        origin: options.origin || '*'
      };
      return W3gram._.jsonRequest('POST', this._appsUrl, {
        mak: mak,
        app: app
      }).then((function(_this) {
        return function(json) {
          json.server = _this.serverUrl;
          return new W3gram._.App(json);
        };
      })(this));
    };

    return Server;

  })();

  W3gram._.WsClient = (function() {
    function WsClient(wsUrl, options) {
      this._wsUrl = wsUrl;
      this._ws = null;
      this._pingPong = new W3gram._.PingPong(options);
      this._pingPong.onPing = (function(_this) {
        return function(data) {
          return _this.sendPing(data);
        };
      })(this);
      this._pingPong.onPingTimeout = (function(_this) {
        return function() {
          return _this.close(4000, 'Ping timeout');
        };
      })(this);
      this._resolveClosed = null;
      this._resolveConnected = null;
      this.connected = null;
      this.closed = new W3gram._.Promise((function(_this) {
        return function(resolve) {
          _this._resolveClosed = resolve;
          _this.connected = new W3gram._.Promise(function(resolve) {
            _this._resolveConnected = resolve;
            _this._connect();
          });
        };
      })(this));
      return;
    }

    WsClient.prototype.close = function(code, message) {
      if (this._ws === null) {
        return;
      }
      this._ws.onclose = null;
      this._ws.onerror = null;
      this._ws.onmessage = null;
      this._ws.onopen = null;
      code || (code = 1000);
      if (code > 1000 && code < 3000) {
        code = 1000;
      }
      this._ws.close(code, message);
      this._ws = null;
      this._pingPong.disconnected();
      this._resolveClosed({
        client: this,
        code: code,
        reason: message
      });
    };

    WsClient.prototype.sendPing = function(data) {
      if (!this._ws) {
        return;
      }
      this._ws.send(JSON.stringify({
        type: 'ping',
        data: data
      }));
    };

    WsClient.prototype.connected = null;

    WsClient.prototype.closed = null;

    WsClient.prototype.onNotification = function(notification) {};

    WsClient.prototype._connect = function() {
      if (this._ws !== null) {
        return;
      }
      this._ws = new W3gram._.WebSocket(this._wsUrl);
      this._ws.onclose = this._onSocketClose.bind(this);
      this._ws.onerror = this._onSocketError.bind(this);
      this._ws.onmessage = this._onSocketMessage.bind(this);
      this._ws.onopen = this._onSocketOpen.bind(this);
      this._pingPong.startedConnecting();
    };

    WsClient.prototype._onMessage = function(message) {
      var type;
      type = message.type;
      if (type === 'pong') {
        this._pingPong.receivedPong(message.data);
        return;
      }
      this._pingPong.receivedMessage();
      if (type === 'note') {
        this.onNotification(message.data);
        return;
      }
      if (type === 'hi') {
        this._resolveConnected(true);
        return;
      }
      this._close(4400, "Invalid message type: " + type);
    };

    WsClient.prototype._onSocketClose = function(closeEvent) {
      if (this._ws !== null) {
        this.close(closeEvent.code, closeEvent.reason);
      }
    };

    WsClient.prototype._onSocketError = function(error) {
      if (this._ws !== null) {
        this.close(4000, error.message);
      }
    };

    WsClient.prototype._onSocketMessage = function(event) {
      var jsonError, message, messageText;
      if (!this._ws) {
        return;
      }
      messageText = event.data;
      message = null;
      try {
        message = JSON.parse(messageText);
      } catch (_error) {
        jsonError = _error;
        this.close(4400, 'Invalid JSON message');
      }
      this._onMessage(message);
    };

    WsClient.prototype._onSocketOpen = function() {};

    return WsClient;

  })();

}).call(this);
